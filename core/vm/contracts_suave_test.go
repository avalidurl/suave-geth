package vm

import (
	"context"
	"encoding/json"
	"fmt"
	"math/big"
	"reflect"
	"strings"
	"testing"

	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/beacon/engine"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/rawdb"
	"github.com/ethereum/go-ethereum/core/state"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/params"
	"github.com/ethereum/go-ethereum/suave/artifacts"
	"github.com/ethereum/go-ethereum/suave/backends"
	suave "github.com/ethereum/go-ethereum/suave/core"
	"github.com/stretchr/testify/require"
)

type mockSuaveBackend struct {
}

func (m *mockSuaveBackend) Start() error { return nil }
func (m *mockSuaveBackend) Stop() error  { return nil }

func (m *mockSuaveBackend) InitializeBid(bid suave.Bid) error {
	return nil
}

func (m *mockSuaveBackend) Store(bid suave.Bid, caller common.Address, key string, value []byte) (suave.Bid, error) {
	return suave.Bid{}, nil
}

func (m *mockSuaveBackend) Retrieve(bid suave.Bid, caller common.Address, key string) ([]byte, error) {
	return nil, nil
}

func (m *mockSuaveBackend) SubmitBid(types.Bid) error {
	return nil
}

func (m *mockSuaveBackend) FetchEngineBidById(suave.BidId) (suave.Bid, error) {
	return suave.Bid{}, nil
}

func (m *mockSuaveBackend) FetchBidById(suave.BidId) (suave.Bid, error) {
	return suave.Bid{}, nil
}

func (m *mockSuaveBackend) FetchBidsByProtocolAndBlock(blockNumber uint64, namespace string) []suave.Bid {
	return nil
}

func (m *mockSuaveBackend) BuildEthBlock(ctx context.Context, args *suave.BuildBlockArgs, txs types.Transactions) (*engine.ExecutionPayloadEnvelope, error) {
	return nil, nil
}

func (m *mockSuaveBackend) BuildEthBlockFromBundles(ctx context.Context, args *suave.BuildBlockArgs, bundles []types.SBundle) (*engine.ExecutionPayloadEnvelope, error) {
	return nil, nil
}

func (m *mockSuaveBackend) Subscribe() (<-chan suave.DAMessage, context.CancelFunc) {
	return nil, func() {}
}

func (m *mockSuaveBackend) Publish(suave.DAMessage) {}

var dummyBlockContext = BlockContext{
	CanTransfer: func(StateDB, common.Address, *big.Int) bool { return true },
	Transfer:    func(StateDB, common.Address, common.Address, *big.Int) {},
	BlockNumber: big.NewInt(0),
}

func TestSuavePrecompileStub(t *testing.T) {
	// This test ensures that the Suave precompile stubs work as expected
	// for encoding/decoding.
	mockSuaveBackend := &mockSuaveBackend{}
	stubEngine := suave.NewConfidentialStoreEngine(mockSuaveBackend, mockSuaveBackend, suave.MockSigner{}, suave.MockChainSigner{})

	reqTx := types.NewTx(&types.ConfidentialComputeRequest{
		ExecutionNode: common.Address{},
	})

	suaveContext := SuaveContext{
		Backend: &SuaveExecutionBackend{
			ConfidentialStore:      stubEngine.NewTransactionalStore(reqTx),
			ConfidentialEthBackend: mockSuaveBackend,
		},
		ConfidentialComputeRequestTx: reqTx,
	}

	statedb, _ := state.New(types.EmptyRootHash, state.NewDatabase(rawdb.NewMemoryDatabase()), nil)
	vmenv := NewConfidentialEVM(suaveContext, dummyBlockContext, TxContext{}, statedb, params.AllEthashProtocolChanges, Config{IsConfidential: true})

	// The objective of the unit test is to make sure that the encoding of the precompile
	// inputs works as expected from the ABI specification. Thus, we will skip any errors
	// that are generated by the logic of the precompile.
	// Note: Once code generated is in place, we can remove this and only test the
	// encodings in isolation outside the logic.
	expectedErrors := []string{
		// json error when the precompile expects to decode a json object encoded as []byte
		// in the precompile input.
		"invalid character",
		"not allowed to store",
		"not allowed to retrieve",
		"unknown bid version",
		// error from a precompile that expects to make an http request from an input value.
		"could not send request to relay",
		// error in 'buildEthBlock' when it expects to retrieve bids in abi format from the
		// confidential store.
		"could not unpack merged bid ids",
	}

	for name, addr := range artifacts.SuaveMethods {
		abiMethod, ok := artifacts.SuaveAbi.Methods[name]
		if !ok {
			t.Fatalf("abi method '%s' not found", name)
		}

		inputVals := abi.GenerateRandomTypeForMethod(abiMethod)

		packedInput, err := abiMethod.Inputs.Pack(inputVals...)
		require.NoError(t, err)

		_, _, err = vmenv.Call(AccountRef(common.Address{}), addr, packedInput, 100000000, big.NewInt(0))
		if err != nil {
			found := false
			for _, expectedError := range expectedErrors {
				if strings.Contains(err.Error(), expectedError) {
					found = true
				}
			}
			if !found {
				t.Fatal(err)
			}
		}
	}
}

func newTestBackend(t *testing.T) *suaveRuntime {
	confStore := backends.NewLocalConfidentialStore()
	confEngine := suave.NewConfidentialStoreEngine(confStore, &suave.MockTransport{}, suave.MockSigner{}, suave.MockChainSigner{})

	require.NoError(t, confEngine.Start())
	t.Cleanup(func() { confEngine.Stop() })

	reqTx := types.NewTx(&types.ConfidentialComputeRequest{
		ExecutionNode: common.Address{},
	})

	b := &suaveRuntime{
		suaveContext: &SuaveContext{
			Backend: &SuaveExecutionBackend{
				ConfidentialStore:      confEngine.NewTransactionalStore(reqTx),
				ConfidentialEthBackend: &mockSuaveBackend{},
			},
			ConfidentialComputeRequestTx: reqTx,
		},
	}
	return b
}

func TestSuave_BidWorkflow(t *testing.T) {
	b := newTestBackend(t)

	bid5, err := b.newBid(5, []common.Address{{0x1}}, nil, "a")
	require.NoError(t, err)

	bid10, err := b.newBid(10, []common.Address{{0x1}}, nil, "a")
	require.NoError(t, err)

	bid10b, err := b.newBid(10, []common.Address{{0x1}}, nil, "a")
	require.NoError(t, err)

	cases := []struct {
		cond      uint64
		namespace string
		bids      []types.Bid
	}{
		{0, "a", []types.Bid{}},
		{5, "a", []types.Bid{bid5}},
		{10, "a", []types.Bid{bid10, bid10b}},
		{11, "a", []types.Bid{}},
	}

	for _, c := range cases {
		bids, err := b.fetchBids(c.cond, c.namespace)
		require.NoError(t, err)
		require.Equal(t, c.bids, bids)
	}
}

func TestSuave_ConfStoreWorkflow(t *testing.T) {
	b := newTestBackend(t)

	callerAddr := common.Address{0x1}
	data := []byte{0x1}

	// cannot store a value for a bid that does not exist
	err := b.confidentialStoreStore(types.BidId{}, "key", data)
	require.Error(t, err)

	bid, err := b.newBid(5, []common.Address{callerAddr}, nil, "a")
	require.NoError(t, err)

	// cannot store the bid if the caller is not allowed to
	err = b.confidentialStoreStore(bid.Id, "key", data)
	require.Error(t, err)

	// now, the caller is allowed to store the bid
	b.suaveContext.CallerStack = append(b.suaveContext.CallerStack, &callerAddr)
	err = b.confidentialStoreStore(bid.Id, "key", data)
	require.NoError(t, err)

	val, err := b.confidentialStoreRetrieve(bid.Id, "key")
	require.NoError(t, err)
	require.Equal(t, data, val)

	// cannot retrieve the value if the caller is not allowed to
	b.suaveContext.CallerStack = []*common.Address{}
	_, err = b.confidentialStoreRetrieve(bid.Id, "key")
	require.Error(t, err)
}

func TestXXXX(t *testing.T) {
	r := &runtime{}

	typr, err := abi.NewType("tuple", "", []abi.ArgumentMarshaling{{Name: "param1", Type: "bool"}})
	if err != nil {
		panic(err)
	}
	fmt.Println(typr)

	require.NoError(t, r.Register(&isConfidentialPrecompile2{}))
}

type runtime struct {
}

func (r *runtime) Register(fn interface{}) error {
	// reflect and generate the type of the 'Do' function
	typ := reflect.TypeOf(fn)

	methodName := "Do"
	method, found := typ.MethodByName(methodName)
	if !found {
		return fmt.Errorf("Method %s not found on the interface\n", methodName)
	}

	// It needs at least one output parameter (the internal error) and must
	// be the last parameter
	numOuts := method.Type.NumOut()
	if numOuts == 0 {
		return fmt.Errorf("Method %s must have at least one output parameter\n", methodName)
	}
	if !isErrorType(method.Type.Out(numOuts - 1)) {
		return fmt.Errorf("Last output parameter of method %s must be an error\n", methodName)
	}

	// convert the function input/outputs to ABI format
	xx := convertStructToABITypes(methodInputStructType(method))
	yy, _ := json.Marshal(xx)
	fmt.Println(string(yy))

	/*
		fmt.Println("-- comps --")
		fmt.Println(xx.Components)

		typr, err := abi.NewType("tuple", "", xx.Components)
		if err != nil {
			panic(err)
		}
		fmt.Println(typr)

		abi.NewMethod("", "", abi.Function, "", false, false, nil, nil)
	*/

	return nil
}

var errt = reflect.TypeOf((*error)(nil)).Elem()

func isErrorType(t reflect.Type) bool {
	return t.Implements(errt)
}

type abiField struct {
	Type    string      `json:"type"`
	Name    string      `json:"name"`
	Inputs  []arguments `json:"inputs,omitempty"`
	Outputs []arguments `json:"outputs,omitempty"`
}

type arguments struct {
	Name         string      `json:"name"`
	Type         string      `json:"type"`
	InternalType string      `json:"internalType,omitempty"`
	Components   []arguments `json:"components,omitempty"`
	Indexed      bool        `json:"indexed,omitempty"`
}

func convertStructToABITypes(typ reflect.Type) []arguments {
	if typ.Kind() != reflect.Struct {
		panic("not a struct")
	}

	numFields := typ.NumField()
	fields := make([]arguments, numFields)

	for i := 0; i < numFields; i++ {
		field := typ.Field(i)

		fields[i] = arguments{
			Name: field.Name,
		}

		var typeSuffix string
		subType := field.Type

	INFER:
		for {
			switch subType.Kind() {
			case reflect.Slice:
				typeSuffix += "[]"
			case reflect.Array:
				typeSuffix += fmt.Sprintf("[%d]", subType.Len())
			case reflect.Ptr:
			default:
				break INFER
			}

			subType = subType.Elem()
		}

		if subType.Kind() == reflect.Struct {
			fields[i].Components = convertStructToABITypes(subType)
			fields[i].Type = "tuple" + typeSuffix
		} else {
			// parse basic type
			var basicType string
			switch subType.Kind() {
			case reflect.Bool:
				basicType = "bool"
			default:
				panic(fmt.Errorf("unknown type: %s", subType.Kind()))
			}
			fields[i].Type = basicType + typeSuffix
		}
	}

	return fields
}

func methodInputStructType(method reflect.Method) reflect.Type {
	numArgs := method.Func.Type().NumOut() - 1 // Subtract 1 for the receiver
	argTypes := make([]reflect.Type, numArgs)

	// Get the argument types
	for i := 0; i <= numArgs-1; i++ {
		argTypes[i] = method.Func.Type().Out(i)
	}

	// Create a struct type with the argument types as fields
	structFields := make([]reflect.StructField, numArgs)
	for i, argType := range argTypes {
		structFields[i] = reflect.StructField{
			Name: fmt.Sprintf("Param%d", i+1),
			Type: argType,
		}
	}

	return reflect.StructOf(structFields)
}
